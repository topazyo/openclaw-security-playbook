#!/usr/bin/env python3
"""
Security Tests for Vulnerability Scanning

Tests vulnerability-scanning.py and os-scan.sh integration from Phase 2-3

Test Coverage:
  - OS package scanning (Debian CVEs, Alpine apk)
  - Dependency scanning (npm, pip, Snyk)
  - False positive filtering (EPSS <0.1)
  - Jira ticket creation (P1 for CRITICAL)
  - Auto-remediation and rollback
  - Weekly reporting (CVSS histogram)

Compliance:
  - SOC 2 CC7.1: Threat identification
  - ISO 27001 A.12.6.1: Technical vulnerability management

Usage:
  pytest tests/security/test_vulnerability_scanning.py -v
"""

import pytest
from unittest.mock import Mock, patch, MagicMock
import json


@pytest.fixture
def mock_trivy_output():
    """Mock Trivy scan output."""
    return {
        "Results": [
            {
                "Target": "debian:12",
                "Vulnerabilities": [
                    {
                        "VulnerabilityID": "CVE-2024-0001",
                        "Severity": "CRITICAL",
                        "PkgName": "openssl",
                        "InstalledVersion": "1.1.1",
                        "FixedVersion": "1.1.1w",
                    }
                ],
            }
        ]
    }


class TestOSPackageScanning:
    """Test OS package vulnerability scanning."""
    
    @patch("subprocess.run")
    def test_os_scan_detects_debian_cves(self, mock_subprocess, mock_trivy_output):
        """Test os-scan.sh detects Debian CVEs."""
        mock_subprocess.return_value.stdout = json.dumps(mock_trivy_output)
        mock_subprocess.return_value.returncode = 0
        
        from scripts.discovery import os_scan
        
        vulns = os_scan.scan_os_packages(image="debian:12")
        
        assert len(vulns) > 0
        assert vulns[0]["VulnerabilityID"] == "CVE-2024-0001"
        assert vulns[0]["Severity"] == "CRITICAL"
    
    @patch("subprocess.run")
    def test_alpine_apk_vulnerabilities(self, mock_subprocess):
        """Test Alpine apk vulnerabilities detected."""
        mock_output = {
            "Results": [
                {
                    "Target": "alpine:3.19",
                    "Vulnerabilities": [
                        {
                            "VulnerabilityID": "CVE-2024-0002",
                            "Severity": "HIGH",
                            "PkgName": "busybox",
                        }
                    ],
                }
            ]
        }
        
        mock_subprocess.return_value.stdout = json.dumps(mock_output)
        mock_subprocess.return_value.returncode = 0
        
        from scripts.discovery import os_scan
        
        vulns = os_scan.scan_os_packages(image="alpine:3.19")
        
        assert any(v["PkgName"] == "busybox" for v in vulns)


class TestDependencyScanning:
    """Test dependency vulnerability scanning."""
    
    @patch("subprocess.run")
    def test_npm_audit_finds_outdated(self, mock_subprocess):
        """Test npm audit finds outdated packages."""
        npm_output = {
            "advisories": {
                "1": {
                    "severity": "high",
                    "title": "Prototype Pollution",
                    "module_name": "lodash",
                    "vulnerable_versions": "<4.17.21",
                }
            }
        }
        
        mock_subprocess.return_value.stdout = json.dumps(npm_output)
        mock_subprocess.return_value.returncode = 0
        
        from scripts.discovery import dependency_scan
        
        vulns = dependency_scan.scan_npm_packages()
        
        assert len(vulns) > 0
        assert "lodash" in vulns[0]["module_name"]
    
    @patch("subprocess.run")
    def test_pip_audit_detects_python_vulns(self, mock_subprocess):
        """Test pip-audit detects Python vulnerabilities."""
        pip_output = [
            {
                "name": "requests",
                "version": "2.25.0",
                "vulns": [
                    {
                        "id": "PYSEC-2022-01",
                        "fix_versions": ["2.31.0"],
                    }
                ],
            }
        ]
        
        mock_subprocess.return_value.stdout = json.dumps(pip_output)
        
        from scripts.discovery import dependency_scan
        
        vulns = dependency_scan.scan_python_packages()
        
        assert any(v["name"] == "requests" for v in vulns)


class TestFalsePositiveFiltering:
    """Test false positive filtering."""
    
    def test_epss_below_threshold_filtered(self):
        """Test vulnerabilities with EPSS <0.1 are filtered."""
        from scripts.supply_chain import check_applicability
        
        vulns = [
            {"id": "CVE-2024-0001", "epss_score": 0.05},  # Low probability
            {"id": "CVE-2024-0002", "epss_score": 0.85},  # High probability
        ]
        
        filtered = check_applicability.filter_by_epss(vulns, threshold=0.1)
        
        assert len(filtered) == 1
        assert filtered[0]["id"] == "CVE-2024-0002"
    
    def test_inactive_package_cves_removed(self):
        """Test check-applicability.py removes inactive package CVEs."""
        from scripts.supply_chain import check_applicability
        
        vulns = [
            {"id": "CVE-2024-0001", "pkg": "openssl", "code_path": None},  # Not used
            {"id": "CVE-2024-0002", "pkg": "requests", "code_path": "app/api.py"},  # Used
        ]
        
        filtered = check_applicability.filter_inactive_packages(vulns)
        
        assert len(filtered) == 1
        assert filtered[0]["id"] == "CVE-2024-0002"


class TestJiraTicketCreation:
    """Test Jira ticket creation for vulnerabilities."""
    
    @patch("requests.post")
    def test_critical_creates_p1_ticket(self, mock_post):
        """Test CRITICAL vuln creates P1 Jira ticket."""
        mock_post.return_value.status_code = 201
        mock_post.return_value.json.return_value = {"key": "SEC-123"}
        
        from scripts.incident_response import create_tickets
        
        vuln = {
            "id": "CVE-2024-0001",
            "severity": "CRITICAL",
            "description": "RCE in OpenSSL",
        }
        
        ticket = create_tickets.create_jira_ticket(vuln)
        
        assert ticket["priority"] == "P1"
        assert ticket["key"] == "SEC-123"
    
    @patch("requests.get")
    def test_duplicate_tickets_prevented(self, mock_get):
        """Test deduplication prevents duplicate Jira tickets."""
        # Existing ticket found
        mock_get.return_value.json.return_value = {
            "issues": [{"key": "SEC-100", "fields": {"summary": "CVE-2024-0001"}}]
        }
        
        from scripts.incident_response import create_tickets
        
        vuln = {"id": "CVE-2024-0001", "severity": "HIGH"}
        
        ticket = create_tickets.create_jira_ticket(vuln)
        
        # Should return existing ticket
        assert ticket["key"] == "SEC-100"
        assert ticket["duplicate"] is True


class TestAutoRemediation:
    """Test auto-remediation and rollback."""
    
    @patch("subprocess.run")
    def test_allowlisted_low_vulns_patched(self, mock_subprocess):
        """Test auto-remediate.sh patches allowlisted LOW vulns."""
        mock_subprocess.return_value.returncode = 0
        
        from scripts.remediation import auto_remediate
        
        vuln = {
            "id": "CVE-2024-0003",
            "severity": "LOW",
            "pkg": "curl",
            "allowlisted": True,
        }
        
        result = auto_remediate.patch_vulnerability(vuln)
        
        assert result["status"] == "patched"
    
    @patch("subprocess.run")
    def test_rollback_on_service_failure(self, mock_subprocess):
        """Test rollback occurs if service fails after patching."""
        # First call: patch succeeds
        # Second call: health check fails
        mock_subprocess.side_effect = [
            Mock(returncode=0),  # Patch success
            Mock(returncode=1),  # Health check failure
        ]
        
        from scripts.remediation import auto_remediate
        
        vuln = {"id": "CVE-2024-0004", "pkg": "nginx"}
        
        result = auto_remediate.patch_vulnerability(vuln)
        
        assert result["status"] == "rolled_back"
        assert "health_check_failed" in result["reason"]


class TestWeeklyReporting:
    """Test vulnerability reporting."""
    
    @patch("subprocess.run")
    def test_weekly_report_cvss_histogram(self, mock_subprocess):
        """Test generate-weekly-report.py includes CVSS histogram."""
        from scripts.reporting import generate_weekly_report
        
        report = generate_weekly_report.generate(
            start_date="2024-01-15",
            end_date="2024-01-22",
        )
        
        assert "cvss_histogram" in report
        assert "CRITICAL" in report["cvss_histogram"]
        assert "patching_velocity" in report


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
