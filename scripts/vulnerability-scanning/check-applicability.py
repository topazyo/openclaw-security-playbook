#!/usr/bin/env python3
"""
Vulnerability Applicability Checker

Purpose: Filter false positives by checking if vulnerable packages are actually exploitable
Attack Vectors: Reduces noise, focuses remediation on real threats
Compliance: SOC 2 CC7.1, ISO 27001 A.12.6.1

Checks:
1. Is the vulnerable package/service actually running?
2. Is the vulnerable port exposed?
3. Is there a known exploit available (EPSS scoring)?
4. Are prerequisites for exploitation met?

Usage:
    python3 check-applicability.py --input scan.json --output filtered.json
    python3 check-applicability.py --input scan.json --check-running --check-epss

Dependencies: psutil, requests

Related: os-scan.sh, create-tickets.py
"""

import argparse
import json
import logging
import os
import subprocess
import sys
from typing import Dict, List, Optional
from datetime import datetime

try:
    import psutil
    import requests
except ImportError:
    print("ERROR: Missing dependencies. Install with: pip install psutil requests")
    sys.exit(1)

# Configuration
EPSS_API_URL = "https://api.first.org/data/v1/epss"
NVD_API_KEY = os.getenv("NVD_API_KEY")
NVD_API_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0"

# Logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


def get_running_processes() -> Dict[str, List[Dict]]:
    """Get all running processes with command details"""
    processes = {}
    
    for proc in psutil.process_iter(['pid', 'name', 'cmdline', 'connections']):
        try:
            pinfo = proc.info
            name = pinfo['name']
            
            if name not in processes:
                processes[name] = []
            
            processes[name].append({
                'pid': pinfo['pid'],
                'cmdline': ' '.join(pinfo['cmdline'] or []),
                'connections': pinfo.get('connections', [])
            })
        except (psutil.NoSuchProcess, psutil.AccessDenied):
            continue
    
    return processes


def get_listening_ports() -> List[int]:
    """Get all TCP/UDP ports that are listening"""
    ports = set()
    
    for conn in psutil.net_connections(kind='inet'):
        if conn.status== 'LISTEN':
            ports.add(conn.laddr.port)
    
    return sorted(list(ports))


def check_package_in_use(package_name: str, running_procs: Dict[str, List[Dict]]) -> bool:
    """Check if a package/library is currently in use by a running process"""
    
    # Common package name mappings
    process_mappings = {
        'openssl': ['openssl', 'sshd', 'nginx', 'apache2', 'httpd'],
        'glibc': ['*'],  # All processes use glibc
        'python3': ['python', 'python3'],
        'nodejs': ['node', 'nodejs'],
        'nginx': ['nginx'],
        'apache2': ['apache2', 'httpd'],
        'openssh': ['sshd'],
        'systemd': ['systemd']
    }
    
    # If package maps to all processes, it's in use
    if package_name in process_mappings and '*' in process_mappings[package_name]:
        return True
    
    # Check specific process names
    target_procs = process_mappings.get(package_name, [package_name])
    
    for proc_name in target_procs:
        if proc_name in running_procs:
            logger.debug(f"Package {package_name} is active (process: {proc_name})")
            return True
    
    return False


def check_port_exposed(vulnerability: Dict, listening_ports: List[int]) -> bool:
    """Check if vulnerability affects an exposed network service"""
    
    # Common port mappings for services
    service_ports = {
        'openssh': [22],
        'nginx': [80, 443],
        'apache2': [80, 443],
        'mysql': [3306],
        'postgresql': [5432],
        'redis': [6379],
        'mongodb': [27017]
    }
    
    package_name = vulnerability['package_name'].lower()
    
    # Check if any known ports for this service are listening
    for service, ports in service_ports.items():
        if service in package_name:
            for port in ports:
                if port in listening_ports:
                    logger.info(f"Service {package_name} exposed on port {port}")
                    return True
    
    return False


def query_epss_score(cve_id: str) -> Optional[float]:
    """Query EPSS API for exploitation probability score"""
    
    try:
        response = requests.get(
            EPSS_API_URL,
            params={'cve': cve_id},
            timeout=5
        )
        response.raise_for_status()
        
        data = response.json()
        if data.get('data'):
            epss_score = float(data['data'][0].get('epss', 0))
            logger.debug(f"{cve_id} EPSS score: {epss_score}")
            return epss_score
        
    except requests.exceptions.RequestException as e:
        logger.warning(f"Failed to query EPSS for {cve_id}: {e}")
    
    return None


def query_nvd_details(cve_id: str) -> Optional[Dict]:
    """Query NVD API for CVE details including exploit availability"""
    
    if not NVD_API_KEY:
        logger.warning("NVD_API_KEY not set, skipping NVD lookup")
        return None
    
    headers = {'apiKey': NVD_API_KEY}
    
    try:
        response = requests.get(
            NVD_API_URL,
            params={'cveId': cve_id},
            headers=headers,
            timeout=10
        )
        response.raise_for_status()
        
        data = response.json()
        if data.get('vulnerabilities'):
            cve_data = data['vulnerabilities'][0]['cve']
            
            # Check for references to exploits
            has_exploit = False
            references = cve_data.get('references', [])
            for ref in references:
                tags = ref.get('tags', [])
                if 'Exploit' in tags or 'exploit' in ref.get('url', '').lower():
                    has_exploit = True
                    break
            
            return {
                'has_exploit': has_exploit,
                'description': cve_data.get('descriptions', [{}])[0].get('value', ''),
                'published': cve_data.get('published'),
                'references': references
            }
    
    except requests.exceptions.RequestException as e:
        logger.warning(f"Failed to query NVD for {cve_id}: {e}")
    
    return None


def calculate_applicability_score(vuln: Dict, checks: Dict) -> float:
    """Calculate applicability score (0.0 - 1.0) based on multiple factors"""
    
    score = 0.0
    weights = {
        'is_running': 0.4,
        'port_exposed': 0.3,
        'has_exploit': 0.2,
        'epss_high': 0.1
    }
    
    if checks.get('is_running'):
        score += weights['is_running']
    
    if checks.get('port_exposed'):
        score += weights['port_exposed']
    
    if checks.get('has_exploit'):
        score += weights['has_exploit']
    
    epss = checks.get('epss_score', 0)
    if epss > 0.5:  # High exploitation probability
        score += weights['epss_high']
    
    return round(score, 2)


def assess_vulnerability(vuln: Dict, running_procs: Dict, listening_ports: List[int],
                        check_running: bool = True, check_ports: bool = True,
                        check_epss: bool = True, check_nvd: bool = False) -> Dict:
    """Assess if vulnerability is actually exploitable in current environment"""
    
    cve_id = vuln['cve_id']
    package_name = vuln['package_name']
    
    logger.info(f"Assessing {cve_id} in {package_name}...")
    
    checks = {
        'is_running': False,
        'port_exposed': False,
        'has_exploit': False,
        'epss_score': 0.0
    }
    
    # Check if package/service is running
    if check_running:
        checks['is_running'] = check_package_in_use(package_name, running_procs)
    
    # Check if vulnerable service has exposed ports
    if check_ports and checks['is_running']:
        checks['port_exposed'] = check_port_exposed(vuln, listening_ports)
    
    # Query EPSS for exploitation probability
    if check_epss:
        epss_score = query_epss_score(cve_id)
        if epss_score is not None:
            checks['epss_score'] = epss_score
    
    # Query NVD for exploit availability
    if check_nvd:
        nvd_data = query_nvd_details(cve_id)
        if nvd_data:
            checks['has_exploit'] = nvd_data['has_exploit']
    
    # Calculate overall applicability score
    applicability_score = calculate_applicability_score(vuln, checks)
    
    # Determine if applicable
    is_applicable = applicability_score >= 0.3  # Threshold: 30%
    
    result = {
        **vuln,
        'applicability_checks': checks,
        'applicability_score': applicability_score,
        'is_applicable': is_applicable,
        'assessment_date': datetime.utcnow().isoformat()
    }
    
    logger.info(f"{cve_id}: score={applicability_score}, applicable={is_applicable}")
    
    return result


def main():
    parser = argparse.ArgumentParser(
        description="Check vulnerability applicability and filter false positives",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    # Full applicability check
    python3 check-applicability.py --input scan.json --output filtered.json \\
        --check-running --check-ports --check-epss
    
    # Quick check (running processes only)
    python3 check-applicability.py --input scan.json --check-running
    
    # Filter to only applicable vulnerabilities
    python3 check-applicability.py --input scan.json --output applicable-only.json \\
        --filter-applicable

Environment Variables:
    NVD_API_KEY        NVD API key for detailed CVE lookups (optional)

Notes:
    - Requires elevated privileges for full process inspection
    - EPSS scores range 0.0-1.0 (probability of exploitation)
    - Applicability score >= 0.3 considered applicable
        """
    )
    
    parser.add_argument(
        "--input",
        required=True,
        help="Path to vulnerability scan results JSON"
    )
    parser.add_argument(
        "--output",
        help="Path to output filtered results (default: input_filtered.json)"
    )
    parser.add_argument(
        "--check-running",
        action="store_true",
        default=True,
        help="Check if vulnerable packages are running (default: True)"
    )
    parser.add_argument(
        "--check-ports",
        action="store_true",
        default=True,
        help="Check if vulnerable services have exposed ports (default: True)"
    )
    parser.add_argument(
        "--check-epss",
        action="store_true",
        help="Query EPSS API for exploitation probability"
    )
    parser.add_argument(
        "--check-nvd",
        action="store_true",
        help="Query NVD API for exploit details (requires NVD_API_KEY)"
    )
    parser.add_argument(
        "--filter-applicable",
        action="store_true",
        help="Output only applicable vulnerabilities (score >= 0.3)"
    )
    parser.add_argument(
        "--severity",
        help="Filter by severity (comma-separated: CRITICAL,HIGH,MEDIUM,LOW)"
    )
    
    args = parser.parse_args()
    
    # Determine output file
    if not args.output:
        base = os.path.splitext(args.input)[0]
        args.output = f"{base}_filtered.json"
    
    # Load vulnerability data
    try:
        with open(args.input, 'r') as f:
            data = json.load(f)
        
        vulnerabilities = []
        for result in data.get("Results", []):
            for vuln in result.get("Vulnerabilities", []):
                vulnerabilities.append({
                    "cve_id": vuln.get("VulnerabilityID"),
                    "severity": vuln.get("Severity"),
                    "package_name": vuln.get("PkgName"),
                    "installed_version": vuln.get("InstalledVersion"),
                    "fixed_version": vuln.get("FixedVersion", "N/A"),
                    "cvss_score": vuln.get("CVSS", {}).get("nvd", {}).get("V3Score", 0),
                    "description": vuln.get("Description", "")
                })
    except Exception as e:
        logger.error(f"Failed to load input file: {e}")
        return 1
    
    # Filter by severity if specified
    if args.severity:
        severities = [s.strip().upper() for s in args.severity.split(',')]
        vulnerabilities = [v for v in vulnerabilities if v['severity'] in severities]
    
    logger.info(f"Assessing {len(vulnerabilities)} vulnerabilities...")
    
    # Get system state
    running_procs = get_running_processes()
    listening_ports = get_listening_ports()
    
    logger.info(f"Found {len(running_procs)} unique process types")
    logger.info(f"Found {len(listening_ports)} listening ports")
    
    # Assess each vulnerability
    results = []
    for vuln in vulnerabilities:
        result = assess_vulnerability(
            vuln,
            running_procs,
            listening_ports,
            check_running=args.check_running,
            check_ports=args.check_ports,
            check_epss=args.check_epss,
            check_nvd=args.check_nvd
        )
        results.append(result)
    
    # Filter if requested
    if args.filter_applicable:
        results = [r for r in results if r['is_applicable']]
        logger.info(f"Filtered to {len(results)} applicable vulnerabilities")
    
    # Generate summary
    total = len(results)
    applicable = sum(1 for r in results if r['is_applicable'])
    not_applicable = total - applicable
    
    by_severity = {}
    for r in results:
        sev = r['severity']
        by_severity[sev] = by_severity.get(sev, 0) + 1
    
    # Save results
    output_data = {
        "assessment_date": datetime.utcnow().isoformat(),
        "total_vulnerabilities": total,
        "applicable_vulnerabilities": applicable,
        "not_applicable_vulnerabilities": not_applicable,
        "by_severity": by_severity,
        "results": results
    }
    
    with open(args.output, 'w') as f:
        json.dump(output_data, f, indent=2)
    
    logger.info(f"Results saved to {args.output}")
    
    # Print summary
    print(f"\n{'='*80}")
    print(f"Applicability Assessment Summary")
    print(f"{'='*80}")
    print(f"Total vulnerabilities: {total}")
    print(f"Applicable (score >= 0.3): {applicable} ({applicable/total*100:.1f}%)")
    print(f"Not applicable: {not_applicable} ({not_applicable/total*100:.1f}%)")
    print(f"\nBy Severity:")
    for sev in ["CRITICAL", "HIGH", "MEDIUM", "LOW"]:
        count = by_severity.get(sev, 0)
        if count > 0:
            print(f"  {sev}: {count}")
    print(f"{'='*80}")
    
    return 0


if __name__ == "__main__":
    sys.exit(main())
