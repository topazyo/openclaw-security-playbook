#!/usr/bin/env bash
# OS-Level CVE Scanning with Trivy
# 
# Purpose: Scan operating system packages for known CVEs using Aqua Trivy scanner
# Attack Vectors Addressed: Unpatched OS vulnerabilities, outdated system packages
# Compliance: SOC 2 CC7.1 (Risk Mitigation), ISO 27001 A.12.6.1 (Technical Vulnerabilities)
#
# Dependencies:
#   - Trivy (aquasecurity/trivy)
#   - jq for JSON processing
#   - curl for NVD API queries
#
# Usage:
#   ./os-scan.sh --target [alpine|debian|ubuntu|rhel] --format [table|json|sarif] --output report.json
#
# Related: vulnerability-scanning.py, dashboard-system-health.json Panel 10

set -euo pipefail

# Color output
readonly RED='\033[0;31m'
readonly YELLOW='\033[1;33m'
readonly GREEN='\033[0;32m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

# Script configuration
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly LOG_DIR="${LOG_DIR:-/var/log/openclaw}"
readonly REPORT_DIR="${REPORT_DIR:-${SCRIPT_DIR}/../../reports/vulnerabilities}"
readonly TRIVY_CACHE_DIR="${HOME}/.cache/trivy"
readonly TRIVY_VERSION="0.48.0"

# Severity thresholds (per SEC-003 patch SLA policy)
readonly CRITICAL_SLA_DAYS=7
readonly HIGH_SLA_DAYS=30
readonly MEDIUM_SLA_DAYS=90

# Logging
log_info() {
    echo -e "${BLUE}[INFO]${NC} $(date '+%Y-%m-%d %H:%M:%S') $*" | tee -a "${LOG_DIR}/os-scan.log"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $(date '+%Y-%m-%d %H:%M:%S') $*" | tee -a "${LOG_DIR}/os-scan.log"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $(date '+%Y-%m-%d %H:%M:%S') $*" | tee -a "${LOG_DIR}/os-scan.log"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $(date '+%Y-%m-%d %H:%M:%S') $*" | tee -a "${LOG_DIR}/os-scan.log"
}

# Help message
show_help() {
    cat << EOF
OS-Level CVE Scanner using Trivy

Usage: $0 [OPTIONS]

Options:
    --target TARGET      Target OS distribution (alpine|debian|ubuntu|rhel|auto)
                        Default: auto-detect
    --format FORMAT      Output format (table|json|sarif|cyclonedx)
                        Default: json
    --output FILE        Output file path
                        Default: ${REPORT_DIR}/os-scan-TIMESTAMP.json
    --severity LEVEL     Minimum severity to report (CRITICAL|HIGH|MEDIUM|LOW)
                        Default: MEDIUM
    --ignore-unfixed     Skip vulnerabilities without fixes
    --update-db          Update vulnerability database before scanning
    --send-to-elk        Send results to Elasticsearch
    --create-tickets     Auto-create Jira tickets for CRITICAL/HIGH
    --help               Show this help message

Examples:
    # Scan local Alpine system
    $0 --target alpine --format table

    # Full production scan with tickets
    $0 --target ubuntu --format json --create-tickets --send-to-elk

    # Quick scan for critical issues only
    $0 --severity CRITICAL --ignore-unfixed

Environment Variables:
    LOG_DIR              Log directory (default: /var/log/openclaw)
    REPORT_DIR           Report output directory
    TRIVY_CACHE_DIR      Trivy cache location
    ELASTICSEARCH_URL    Elasticsearch endpoint for results
    JIRA_API_URL         Jira API endpoint
    JIRA_PROJECT_KEY     Jira project for vulnerability tickets

Related Files:
    - vulnerability-scanning.py (Python vulnerability scanner)
    - create-tickets.py (Jira automation)
    - check-applicability.py (False positive filtering)
EOF
}

# Check prerequisites
check_prerequisites() {
    log_info "Checking prerequisites..."
    
    # Check Trivy installation
    if ! command -v trivy &> /dev/null; then
        log_error "Trivy not found. Installing..."
        install_trivy
    else
        local version=$(trivy --version | grep -oP 'Version: \K[0-9.]+')
        log_info "Trivy version: ${version}"
    fi
    
    # Check jq
    if ! command -v jq &> /dev/null; then
        log_error "jq not found. Install with: apt-get install jq / brew install jq"
        exit 1
    fi
    
    # Create directories
    mkdir -p "${LOG_DIR}" "${REPORT_DIR}" "${TRIVY_CACHE_DIR}"
    
    log_success "Prerequisites check passed"
}

# Install Trivy
install_trivy() {
    log_info "Installing Trivy ${TRIVY_VERSION}..."
    
    if [[ "$OSTYPE" == "linux-gnu"* ]]; then
        # Linux installation
        curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin v${TRIVY_VERSION}
    elif [[ "$OSTYPE" == "darwin"* ]]; then
        # macOS installation
        brew install aquasecurity/trivy/trivy
    else
        log_error "Unsupported OS: ${OSTYPE}"
        exit 1
    fi
    
    log_success "Trivy installed successfully"
}

# Detect OS distribution
detect_os() {
    if [[ -f /etc/os-release ]]; then
        . /etc/os-release
        echo "${ID}"
    elif [[ -f /etc/alpine-release ]]; then
        echo "alpine"
    else
        log_error "Unable to detect OS distribution"
        exit 1
    fi
}

# Update Trivy database
update_database() {
    log_info "Updating Trivy vulnerability database..."
    
    trivy image --download-db-only 2>&1 | tee -a "${LOG_DIR}/os-scan.log"
    
    local db_metadata="${TRIVY_CACHE_DIR}/db/metadata.json"
    if [[ -f "${db_metadata}" ]]; then
        local db_updated=$(jq -r '.UpdatedAt' "${db_metadata}")
        log_success "Database updated: ${db_updated}"
    fi
}

# Run Trivy OS scan
run_scan() {
    local target="$1"
    local format="$2"
    local output="$3"
    local severity="$4"
    local ignore_unfixed="$5"
    
    log_info "Scanning ${target} for vulnerabilities (severity: ${severity})..."
    
    local scan_args=(
        "rootfs"
        "--format" "${format}"
        "--severity" "${severity}"
        "--output" "${output}"
    )
    
    if [[ "${ignore_unfixed}" == "true" ]]; then
        scan_args+=("--ignore-unfixed")
    fi
    
    # Add scanners
    scan_args+=("--scanners" "vuln")
    
    # Target filesystem root
    scan_args+=("/")
    
    # Run scan
    if trivy "${scan_args[@]}" 2>&1 | tee -a "${LOG_DIR}/os-scan.log"; then
        log_success "Scan completed: ${output}"
        return 0
    else
        log_error "Scan failed with exit code $?"
        return 1
    fi
}

# Parse scan results
parse_results() {
    local results_file="$1"
    
    if [[ ! -f "${results_file}" ]]; then
        log_error "Results file not found: ${results_file}"
        return 1
    fi
    
    log_info "Parsing scan results..."
    
    # Extract vulnerability counts by severity
    local critical=$(jq '[.Results[].Vulnerabilities[]? | select(.Severity=="CRITICAL")] | length' "${results_file}")
    local high=$(jq '[.Results[].Vulnerabilities[]? | select(.Severity=="HIGH")] | length' "${results_file}")
    local medium=$(jq '[.Results[].Vulnerabilities[]? | select(.Severity=="MEDIUM")] | length' "${results_file}")
    local low=$(jq '[.Results[].Vulnerabilities[]? | select(.Severity=="LOW")] | length' "${results_file}")
    local total=$((critical + high + medium + low))
    
    echo ""
    echo "======================================"
    echo "    Vulnerability Scan Summary"
    echo "======================================"
    echo -e "${RED}CRITICAL:${NC} ${critical} (Patch SLA: ${CRITICAL_SLA_DAYS} days)"
    echo -e "${YELLOW}HIGH:${NC}     ${high} (Patch SLA: ${HIGH_SLA_DAYS} days)"
    echo -e "${BLUE}MEDIUM:${NC}   ${medium} (Patch SLA: ${MEDIUM_SLA_DAYS} days)"
    echo -e "${GREEN}LOW:${NC}      ${low}"
    echo "--------------------------------------"
    echo "TOTAL:    ${total}"
    echo "======================================"
    echo ""
    
    # Check if action required
    if [[ ${critical} -gt 0 ]]; then
        log_error "${critical} CRITICAL vulnerabilities require immediate patching (${CRITICAL_SLA_DAYS}-day SLA)"
        return 2
    elif [[ ${high} -gt 0 ]]; then
        log_warn "${high} HIGH vulnerabilities require patching within ${HIGH_SLA_DAYS} days"
        return 1
    else
        log_success "No critical or high severity vulnerabilities found"
        return 0
    fi
}

# Send results to Elasticsearch
send_to_elasticsearch() {
    local results_file="$1"
    
    if [[ -z "${ELASTICSEARCH_URL:-}" ]]; then
        log_warn "ELASTICSEARCH_URL not set, skipping upload"
        return 0
    fi
    
    log_info "Sending results to Elasticsearch: ${ELASTICSEARCH_URL}"
    
    # Transform Trivy format to Elasticsearch document
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    local index_name="openclaw-vulnerabilities-$(date +%Y.%m.%d)"
    
    jq -c '.Results[].Vulnerabilities[]? | {
        "@timestamp": "'${timestamp}'",
        "event_type": "VULNERABILITY_DETECTED",
        "vulnerability": {
            "cve_id": .VulnerabilityID,
            "severity": .Severity,
            "cvss_score": (.CVSS.nvd.V3Score // .CVSS.redhat.V3Score // 0),
            "package_name": .PkgName,
            "package_version": .InstalledVersion,
            "fixed_version": .FixedVersion,
            "title": .Title,
            "description": .Description,
            "references": .References,
            "published_date": .PublishedDate,
            "last_modified_date": .LastModifiedDate
        },
        "environment": "production",
        "scanner": "trivy",
        "host": "'$(hostname)'"
    }' "${results_file}" | while IFS= read -r doc; do
        curl -s -X POST "${ELASTICSEARCH_URL}/${index_name}/_doc" \
            -H 'Content-Type: application/json' \
            -d "${doc}" || log_warn "Failed to send document to Elasticsearch"
    done
    
    log_success "Results sent to Elasticsearch index: ${index_name}"
}

# Create Jira tickets for critical/high vulnerabilities
create_jira_tickets() {
    local results_file="$1"
    
    if [[ -z "${JIRA_API_URL:-}" ]] || [[ -z "${JIRA_PROJECT_KEY:-}" ]]; then
        log_warn "Jira configuration not set, skipping ticket creation"
        return 0
    fi
    
    log_info "Creating Jira tickets for CRITICAL/HIGH vulnerabilities..."
    
    # Call create-tickets.py script
    if [[ -f "${SCRIPT_DIR}/create-tickets.py" ]]; then
        python3 "${SCRIPT_DIR}/create-tickets.py" \
            --input "${results_file}" \
            --severity "CRITICAL,HIGH" \
            --project "${JIRA_PROJECT_KEY}"
    else
        log_warn "create-tickets.py not found, skipping"
    fi
}

# Main function
main() {
    local target="auto"
    local format="json"
    local output=""
    local severity="MEDIUM"
    local ignore_unfixed="false"
    local update_db="false"
    local send_elk="false"
    local create_tickets="false"
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --target)
                target="$2"
                shift 2
                ;;
            --format)
                format="$2"
                shift 2
                ;;
            --output)
                output="$2"
                shift 2
                ;;
            --severity)
                severity="$2"
                shift 2
                ;;
            --ignore-unfixed)
                ignore_unfixed="true"
                shift
                ;;
            --update-db)
                update_db="true"
                shift
                ;;
            --send-to-elk)
                send_elk="true"
                shift
                ;;
            --create-tickets)
                create_tickets="true"
                shift
                ;;
            --help)
                show_help
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                show_help
                exit 1
                ;;
        esac
    done
    
    # Auto-detect target if not specified
    if [[ "${target}" == "auto" ]]; then
        target=$(detect_os)
        log_info "Detected OS: ${target}"
    fi
    
    # Set default output filename
    if [[ -z "${output}" ]]; then
        output="${REPORT_DIR}/os-scan-$(date +%Y%m%d-%H%M%S).json"
    fi
    
    # Check prerequisites
    check_prerequisites
    
    # Update database if requested
    if [[ "${update_db}" == "true" ]]; then
        update_database
    fi
    
    # Run scan
    if ! run_scan "${target}" "${format}" "${output}" "${severity}" "${ignore_unfixed}"; then
        log_error "Scan failed"
        exit 1
    fi
    
    # Parse and display results
    parse_results "${output}"
    local result_code=$?
    
    # Send to Elasticsearch
    if [[ "${send_elk}" == "true" ]] && [[ "${format}" == "json" ]]; then
        send_to_elasticsearch "${output}"
    fi
    
    # Create Jira tickets
    if [[ "${create_tickets}" == "true" ]] && [[ "${format}" == "json" ]]; then
        create_jira_tickets "${output}"
    fi
    
    log_success "Scan complete. Report: ${output}"
    
    exit ${result_code}
}

# Run main function
main "$@"
