#!/usr/bin/env python3
"""
Jira Ticket Automation for Vulnerability Management

Purpose: Automatically create Jira tickets for HIGH/CRITICAL vulnerabilities
Attack Vectors Addressed: Untracked vulnerabilities, patch SLA violations
Compliance: SOC 2 CC7.1 (Risk Mitigation), ISO 27001 A.12.6.1
Dependencies: requests, jinja2

Usage:
    python3 create-tickets.py --input scan-results.json --severity CRITICAL,HIGH
    python3 create-tickets.py --input scan-results.json --project VULN --dry-run

Related: os-scan.sh, vulnerability-scanning.py, alert-rules-high.json
"""

import argparse
import json
import logging
import os
import sys
from datetime import datetime, timedelta
from typing import Dict, List, Optional
from urllib.parse import urljoin

try:
    import requests
    from jinja2 import Template
except ImportError:
    print("ERROR: Missing dependencies. Install with: pip install requests jinja2")
    sys.exit(1)

# Configuration from environment
JIRA_API_URL = os.getenv("JIRA_API_URL", "https://your-org.atlassian.net")
JIRA_API_TOKEN = os.getenv("JIRA_API_TOKEN")
JIRA_USER_EMAIL = os.getenv("JIRA_USER_EMAIL")
JIRA_PROJECT_KEY = os.getenv("JIRA_PROJECT_KEY", "VULN")

# Patch SLA (days) per SEC-003 policy
PATCH_SLA = {
    "CRITICAL": 7,
    "HIGH": 30,
    "MEDIUM": 90,
    "LOW": 365  # No formal SLA, tracked annually
}

# Jira priority mapping
PRIORITY_MAP = {
    "CRITICAL": "Highest",
    "HIGH": "High",
    "MEDIUM": "Medium",
    "LOW": "Low"
}

# Logging configuration
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Jira ticket description template
TICKET_DESCRIPTION_TEMPLATE = """
h2. Vulnerability Summary

*CVE ID:* {{cve_id}}
*Severity:* {{severity}} (CVSS {{cvss_score}})
*Package:* {{package_name}}@{{installed_version}}
*Fixed In:* {{fixed_version}}

h2. Description

{{description}}

h2. Impact

*CVSS v3 Score:* {{cvss_score}} / 10.0
*Exploit Available:* {{exploit_available}}
*EPSS Score:* {{epss_score}}% (exploitability probability)

*Affected Systems:*
{% for system in affected_systems %}
- {{system}}
{% endfor %}

h2. Remediation

*Action Required:* Upgrade {{package_name}} from {{installed_version}} to {{fixed_version}}

*Patch SLA:* {{patch_deadline}} ({{days_remaining}} days remaining per SEC-003)

*Steps:*
# Test {{fixed_version}} in staging environment
# Review changelog: {{changelog_url}}
# Deploy via change management process
# Verify with re-scan: {{code}}trivy rootfs --severity {{severity}} /{{code}}
# Update this ticket with deployment date

h2. References

{% for ref in references %}
- [{{ref}}|{{ref}}]
{% endfor %}

h2. Compliance

*Frameworks:*
- SOC 2 CC7.1 (Risk Mitigation)
- ISO 27001 A.12.6.1 (Technical Vulnerabilities Management)
- PCI DSS 6.2 (Security Patches within deadline)

*Evidence Required:*
- Patch deployment timestamp
- Re-scan results showing vulnerability resolved
- Change request approval

---
_Auto-generated by openclaw-security vulnerability scanner_
_Scan Date: {{scan_date}}_
_Scanner: Trivy_
"""


class JiraClient:
    """Jira API client for ticket management"""
    
    def __init__(self, api_url: str, email: str, token: str):
        self.api_url = api_url
        self.session = requests.Session()
        self.session.auth = (email, token)
        self.session.headers.update({
            "Accept": "application/json",
            "Content-Type": "application/json"
        })
    
    def search_issues(self, jql: str) -> List[Dict]:
        """Search for existing issues using JQL"""
        url = urljoin(self.api_url, "/rest/api/3/search")
        params = {
            "jql": jql,
            "maxResults": 100,
            "fields": "key,summary,status"
        }
        
        try:
            response = self.session.get(url, params=params)
            response.raise_for_status()
            return response.json().get("issues", [])
        except requests.exceptions.RequestException as e:
            logger.error(f"Failed to search issues: {e}")
            return []
    
    def create_issue(self, project_key: str, issue_data: Dict) -> Optional[str]:
        """Create a new Jira issue"""
        url = urljoin(self.api_url, "/rest/api/3/issue")
        
        payload = {
            "fields": {
                "project": {"key": project_key},
                "summary": issue_data["summary"],
                "description": {
                    "type": "doc",
                    "version": 1,
                    "content": [
                        {
                            "type": "paragraph",
                            "content": [
                                {
                                    "type": "text",
                                    "text": issue_data["description"]
                                }
                            ]
                        }
                    ]
                },
                "issuetype": {"name": "Bug"},
                "priority": {"name": issue_data["priority"]},
                "labels": issue_data.get("labels", []),
                "duedate": issue_data.get("duedate")
            }
        }
        
        # Add custom fields if available
        if "components" in issue_data:
            payload["fields"]["components"] = [{"name": c} for c in issue_data["components"]]
        
        try:
            response = self.session.post(url, json=payload)
            response.raise_for_status()
            issue_key = response.json()["key"]
            logger.info(f"Created issue: {issue_key}")
            return issue_key
        except requests.exceptions.RequestException as e:
            logger.error(f"Failed to create issue: {e}")
            if hasattr(e.response, 'text'):
                logger.error(f"Response: {e.response.text}")
            return None
    
    def add_comment(self, issue_key: str, comment: str) -> bool:
        """Add comment to existing issue"""
        url = urljoin(self.api_url, f"/rest/api/3/issue/{issue_key}/comment")
        
        payload = {
            "body": {
                "type": "doc",
                "version": 1,
                "content": [
                    {
                        "type": "paragraph",
                        "content": [
                            {
                                "type": "text",
                                "text": comment
                            }
                        ]
                    }
                ]
            }
        }
        
        try:
            response = self.session.post(url, json=payload)
            response.raise_for_status()
            logger.info(f"Added comment to {issue_key}")
            return True
        except requests.exceptions.RequestException as e:
            logger.error(f"Failed to add comment: {e}")
            return False


def parse_trivy_results(results_file: str) -> List[Dict]:
    """Parse Trivy scan results JSON"""
    try:
        with open(results_file, 'r') as f:
            data = json.load(f)
        
        vulnerabilities = []
        for result in data.get("Results", []):
            for vuln in result.get("Vulnerabilities", []):
                vulnerabilities.append({
                    "cve_id": vuln.get("VulnerabilityID"),
                    "severity": vuln.get("Severity"),
                    "package_name": vuln.get("PkgName"),
                    "installed_version": vuln.get("InstalledVersion"),
                    "fixed_version": vuln.get("FixedVersion", "N/A"),
                    "title": vuln.get("Title", ""),
                    "description": vuln.get("Description", ""),
                    "cvss_score": vuln.get("CVSS", {}).get("nvd", {}).get("V3Score", 0),
                    "references": vuln.get("References", []),
                    "published_date": vuln.get("PublishedDate"),
                    "last_modified": vuln.get("LastModifiedDate")
                })
        
        logger.info(f"Parsed {len(vulnerabilities)} vulnerabilities from {results_file}")
        return vulnerabilities
    
    except Exception as e:
        logger.error(f"Failed to parse results: {e}")
        sys.exit(1)


def filter_by_severity(vulnerabilities: List[Dict], severities: List[str]) -> List[Dict]:
    """Filter vulnerabilities by severity level"""
    filtered = [v for v in vulnerabilities if v["severity"] in severities]
    logger.info(f"Filtered to {len(filtered)} vulnerabilities (severity: {','.join(severities)})")
    return filtered


def calculate_due_date(severity: str) -> str:
    """Calculate ticket due date based on patch SLA"""
    sla_days = PATCH_SLA.get(severity, 90)
    due_date = datetime.now() + timedelta(days=sla_days)
    return due_date.strftime("%Y-%m-%d")


def generate_ticket_data(vuln: Dict, scan_date: str) -> Dict:
    """Generate Jira ticket data from vulnerability"""
    
    # Render description from template
    template = Template(TICKET_DESCRIPTION_TEMPLATE)
    description = template.render(
        cve_id=vuln["cve_id"],
        severity=vuln["severity"],
        cvss_score=vuln["cvss_score"],
        package_name=vuln["package_name"],
        installed_version=vuln["installed_version"],
        fixed_version=vuln["fixed_version"],
        description=vuln["description"],
        exploit_available="Unknown",  # Would need additional lookup
        epss_score="N/A",  # Would need EPSS API integration
        affected_systems=["Production servers"],  # Would need asset inventory integration
        patch_deadline=calculate_due_date(vuln["severity"]),
        days_remaining=PATCH_SLA.get(vuln["severity"], 90),
        references=vuln["references"][:5],  # Limit to 5 references
        changelog_url="See references",
        scan_date=scan_date
    )
    
    return {
        "summary": f"{vuln['severity']}: {vuln['cve_id']} in {vuln['package_name']}",
        "description": description,
        "priority": PRIORITY_MAP.get(vuln["severity"], "Medium"),
        "labels": [
            "security",
            "vulnerability",
            f"severity-{vuln['severity'].lower()}",
            f"cve-{vuln['cve_id']}",
            vuln["package_name"]
        ],
        "duedate": calculate_due_date(vuln["severity"]),
        "components": ["Security", "Infrastructure"]
    }


def check_existing_ticket(client: JiraClient, project_key: str, cve_id: str) -> Optional[str]:
    """Check if ticket already exists for this CVE"""
    jql = f'project = {project_key} AND labels = "cve-{cve_id}" AND status != Done'
    issues = client.search_issues(jql)
    
    if issues:
        issue_key = issues[0]["key"]
        logger.info(f"Found existing ticket for {cve_id}: {issue_key}")
        return issue_key
    
    return None


def main():
    parser = argparse.ArgumentParser(
        description="Create Jira tickets for vulnerabilities",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    # Create tickets for CRITICAL vulnerabilities
    python3 create-tickets.py --input scan.json --severity CRITICAL
    
    # Dry-run (no tickets created)
    python3 create-tickets.py --input scan.json --severity CRITICAL,HIGH --dry-run
    
    # Custom project key
    python3 create-tickets.py --input scan.json --project SEC --severity HIGH

Environment Variables:
    JIRA_API_URL        Jira base URL (e.g., https://your-org.atlassian.net)
    JIRA_API_TOKEN      Jira API token
    JIRA_USER_EMAIL     Jira user email
    JIRA_PROJECT_KEY    Default project key (default: VULN)
        """
    )
    
    parser.add_argument(
        "--input",
        required=True,
        help="Path to Trivy scan results JSON file"
    )
    parser.add_argument(
        "--severity",
        default="CRITICAL,HIGH",
        help="Comma-separated severity levels (default: CRITICAL,HIGH)"
    )
    parser.add_argument(
        "--project",
        default=JIRA_PROJECT_KEY,
        help=f"Jira project key (default: {JIRA_PROJECT_KEY})"
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Print ticket data without creating tickets"
    )
    parser.add_argument(
        "--update-existing",
        action="store_true",
        help="Add comments to existing tickets instead of skipping"
    )
    
    args = parser.parse_args()
    
    # Validate Jira credentials
    if not args.dry_run:
        if not all([JIRA_API_TOKEN, JIRA_USER_EMAIL]):
            logger.error("Missing Jira credentials. Set JIRA_API_TOKEN and JIRA_USER_EMAIL")
            sys.exit(1)
    
    # Parse scan results
    vulnerabilities = parse_trivy_results(args.input)
    
    # Filter by severity
    severities = [s.strip().upper() for s in args.severity.split(",")]
    filtered_vulns = filter_by_severity(vulnerabilities, severities)
    
    if not filtered_vulns:
        logger.info("No vulnerabilities found matching criteria")
        return 0
    
    # Initialize Jira client
    if not args.dry_run:
        client = JiraClient(JIRA_API_URL, JIRA_USER_EMAIL, JIRA_API_TOKEN)
    
    # Create tickets
    scan_date = datetime.now().strftime("%Y-%m-%d %H:%M:%S UTC")
    created_count = 0
    skipped_count = 0
    updated_count = 0
    
    for vuln in filtered_vulns:
        cve_id = vuln["cve_id"]
        logger.info(f"Processing {cve_id} ({vuln['severity']})...")
        
        # Generate ticket data
        ticket_data = generate_ticket_data(vuln, scan_date)
        
        if args.dry_run:
            print(f"\n{'='*80}")
            print(f"CVE: {cve_id}")
            print(f"Summary: {ticket_data['summary']}")
            print(f"Priority: {ticket_data['priority']}")
            print(f"Due Date: {ticket_data['duedate']}")
            print(f"Labels: {', '.join(ticket_data['labels'])}")
            print(f"\nDescription:\n{ticket_data['description'][:500]}...")
            created_count += 1
            continue
        
        # Check for existing ticket
        existing_key = check_existing_ticket(client, args.project, cve_id)
        
        if existing_key:
            if args.update_existing:
                comment = f"Re-detected in scan on {scan_date}. Still requires remediation."
                if client.add_comment(existing_key, comment):
                    updated_count += 1
            else:
                logger.info(f"Skipping {cve_id} - ticket exists: {existing_key}")
                skipped_count += 1
            continue
        
        # Create new ticket
        issue_key = client.create_issue(args.project, ticket_data)
        if issue_key:
            created_count += 1
            logger.info(f"✓ Created {issue_key} for {cve_id}")
        else:
            logger.error(f"✗ Failed to create ticket for {cve_id}")
    
    # Summary
    print(f"\n{'='*80}")
    print(f"Ticket Creation Summary")
    print(f"{'='*80}")
    print(f"Total vulnerabilities: {len(filtered_vulns)}")
    print(f"Tickets created: {created_count}")
    print(f"Tickets updated: {updated_count}")
    print(f"Tickets skipped (already exist): {skipped_count}")
    print(f"{'='*80}")
    
    return 0


if __name__ == "__main__":
    sys.exit(main())
