#!/usr/bin/env bash
#
# Automated Vulnerability Remediation Script
#
# Purpose: Safely patch LOW/MEDIUM vulnerabilities with automated rollback
# Attack Vectors: Unpatched vulnerabilities, delayed remediation cycles
# Compliance: SOC 2 CC7.1, ISO 27001 A.12.6.1, PCI DSS 6.2
#
# Safety Features:
# - Allowlist-only patching (pre-approved packages)
# - Snapshot before patching (rollback capability)
# - Service health checks after upgrade
# - Maintenance window enforcement
# - Load average monitoring
#
# Usage:
#     ./auto-remediate.sh --input scan-results.json --severity LOW,MEDIUM
#     ./auto-remediate.sh --dry-run --allowlist /etc/openclaw/remediation-allowlist.txt
#
# Related: os-scan.sh, check-applicability.py

set -euo pipefail

# Colors
readonly RED='\033[0;31m'
readonly YELLOW='\033[1;33m'
readonly GREEN='\033[0;32m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LOG_DIR="${LOG_DIR:-/var/log/openclaw}"
LOG_FILE="${LOG_DIR}/auto-remediate.log"
SNAPSHOT_DIR="${SNAPSHOT_DIR:-/var/lib/openclaw/snapshots}"
ALLOWLIST_FILE="${ALLOWLIST_FILE:-/etc/openclaw/remediation-allowlist.txt}"
MAINTENANCE_WINDOW="${MAINTENANCE_WINDOW:-03:00-05:00}"  # UTC

# Thresholds
MAX_LOAD_AVERAGE=2.0
MIN_DISK_SPACE_GB=10
ROLLBACK_TIMEOUT=300  # 5 minutes

# State
DRY_RUN=false
FORCE=false
SKIP_SNAPSHOT=false
PATCHES_APPLIED=0
FAILURES=0
SNAPSHOT_ID=""

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $*" | tee -a "${LOG_FILE}"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $*" | tee -a "${LOG_FILE}"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*" | tee -a "${LOG_FILE}"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $*" | tee -a "${LOG_FILE}"
}

# Help
show_help() {
    cat << EOF
Automated Vulnerability Remediation

Usage: ${0##*/} [OPTIONS]

Options:
    --input FILE            Path to vulnerability scan results JSON
    --severity LEVELS       Comma-separated severity levels (default: LOW,MEDIUM)
    --allowlist FILE        Path to package allowlist (default: ${ALLOWLIST_FILE})
    --dry-run               Show what would be patched without applying
    --force                 Skip maintenance window check
    --skip-snapshot         Skip snapshot creation (not recommended)
    --help                  Show this help

Examples:
    # Dry-run for LOW severity vulnerabilities
    ./auto-remediate.sh --input scan.json --severity LOW --dry-run
    
    # Patch LOW and MEDIUM with snapshot
    ./auto-remediate.sh --input scan.json --severity LOW,MEDIUM
    
    # Force patching outside maintenance window (use with caution)
    ./auto-remediate.sh --input scan.json --force

Maintenance Window:
    Default: ${MAINTENANCE_WINDOW} UTC
    Set via: MAINTENANCE_WINDOW="01:00-03:00" ./auto-remediate.sh

Safety Checks:
    - Load average < ${MAX_LOAD_AVERAGE}
    - Free disk space > ${MIN_DISK_SPACE_GB}GB
    - Maintenance window enforcement
    - Allowlist validation
    - Service health checks
    - Automatic rollback on failure

EOF
}

# Check prerequisites
check_prerequisites() {
    log_info "Checking prerequisites..."
    
    # Check for required tools
    local required_tools=("jq" "systemctl")
    for tool in "${required_tools[@]}"; do
        if ! command -v "$tool" &> /dev/null; then
            log_error "Required tool not found: $tool"
            exit 1
        fi
    done
    
    # Detect package manager
    if command -v apt-get &> /dev/null; then
        PKG_MANAGER="apt"
    elif command -v yum &> /dev/null; then
        PKG_MANAGER="yum"
    elif command -v apk &> /dev/null; then
        PKG_MANAGER="apk"
    else
        log_error "No supported package manager found (apt/yum/apk)"
        exit 1
    fi
    
    log_info "Package manager: ${PKG_MANAGER}"
    
    # Create directories
    mkdir -p "${LOG_DIR}" "${SNAPSHOT_DIR}"
    
    # Check root privileges
    if [[ $EUID -ne 0 ]]; then
        log_error "This script must be run as root for patching"
        exit 1
    fi
}

# Check if in maintenance window
check_maintenance_window() {
    if [[ "${FORCE}" == "true" ]]; then
        log_warn "Skipping maintenance window check (--force)"
        return 0
    fi
    
    local current_hour=$(date -u +%H:%M)
    local window_start="${MAINTENANCE_WINDOW%%-*}"
    local window_end="${MAINTENANCE_WINDOW##*-}"
    
    if [[ "$current_hour" < "$window_start" || "$current_hour" > "$window_end" ]]; then
        log_error "Outside maintenance window: ${MAINTENANCE_WINDOW} UTC (current: ${current_hour} UTC)"
        log_error "Use --force to override (not recommended for production)"
        exit 1
    fi
    
    log_info "Within maintenance window: ${MAINTENANCE_WINDOW} UTC"
}

# Safety checks
perform_safety_checks() {
    log_info "Performing safety checks..."
    
    # Check load average
    local load_avg=$(uptime | awk -F'load average:' '{print $2}' | awk '{print $1}' | tr -d ',')
    if (( $(echo "$load_avg > $MAX_LOAD_AVERAGE" | bc -l) )); then
        log_error "Load average too high: ${load_avg} (max: ${MAX_LOAD_AVERAGE})"
        exit 1
    fi
    log_info "Load average OK: ${load_avg}"
    
    # Check disk space
    local free_space_gb=$(df -BG / | tail -1 | awk '{print $4}' | tr -d 'G')
    if (( free_space_gb < MIN_DISK_SPACE_GB )); then
        log_error "Insufficient disk space: ${free_space_gb}GB (min: ${MIN_DISK_SPACE_GB}GB)"
        exit 1
    fi
    log_info "Disk space OK: ${free_space_gb}GB free"
}

# Load allowlist
load_allowlist() {
    if [[ ! -f "${ALLOWLIST_FILE}" ]]; then
        log_error "Allowlist file not found: ${ALLOWLIST_FILE}"
        log_error "Create allowlist with approved packages for auto-remediation"
        exit 1
    fi
    
    # Read allowlist (ignore comments and empty lines)
    mapfile -t ALLOWED_PACKAGES < <(grep -v '^#' "${ALLOWLIST_FILE}" | grep -v '^$')
    
    log_info "Loaded ${#ALLOWED_PACKAGES[@]} packages from allowlist"
}

# Create snapshot
create_snapshot() {
    if [[ "${SKIP_SNAPSHOT}" == "true" ]]; then
        log_warn "Skipping snapshot creation (--skip-snapshot)"
        return 0
    fi
    
    log_info "Creating system snapshot..."
    
    SNAPSHOT_ID="remediation-$(date +%Y%m%d-%H%M%S)"
    local snapshot_file="${SNAPSHOT_DIR}/${SNAPSHOT_ID}.tar.gz"
    
    # Snapshot critical system files and package database
    case "${PKG_MANAGER}" in
        apt)
            tar czf "${snapshot_file}" \
                /var/lib/dpkg/status \
                /etc/apt/sources.list \
                /etc/apt/sources.list.d/ \
                2>/dev/null || true
            ;;
        yum)
            tar czf "${snapshot_file}" \
                /var/lib/rpm/ \
                /etc/yum.repos.d/ \
                2>/dev/null || true
            ;;
        apk)
            tar czf "${snapshot_file}" \
                /lib/apk/db/ \
                /etc/apk/repositories \
                2>/dev/null || true
            ;;
    esac
    
    log_success "Snapshot created: ${snapshot_file}"
}

# Parse vulnerabilities from scan results
parse_vulnerabilities() {
    local input_file="$1"
    local severities="$2"
    
    if [[ ! -f "${input_file}" ]]; then
        log_error "Input file not found: ${input_file}"
        exit 1
    fi
    
    log_info "Parsing vulnerabilities (severity: ${severities})..."
    
    # Extract package names with specified severities
    mapfile -t VULN_PACKAGES < <(
        jq -r --arg sev "${severities}" \
            '.Results[]? | .Vulnerabilities[]? | select(.Severity | IN($sev | split(",")[]))  | .PkgName' \
            "${input_file}" | sort -u
    )
    
    log_info "Found ${#VULN_PACKAGES[@]} unique vulnerable packages"
}

# Check if package is in allowlist
is_allowed() {
    local package="$1"
    
    for allowed in "${ALLOWED_PACKAGES[@]}"; do
        if [[ "$package" == "$allowed" ]]; then
            return 0
        fi
    done
    
    return 1
}

# Get services using a package
get_package_services() {
    local package="$1"
    
    case "${PKG_MANAGER}" in
        apt)
            dpkg -L "$package" 2>/dev/null | grep -E '\.service$' | xargs -r basename -a 2>/dev/null || echo ""
            ;;
        yum)
            rpm -ql "$package" 2>/dev/null | grep -E '\.service$' | xargs -r basename -a 2>/dev/null || echo ""
            ;;
        apk)
            apk info -L "$package" 2>/dev/null | grep -E '\.service$' | xargs -r basename -a 2>/dev/null || echo ""
            ;;
    esac
}

# Upgrade package
upgrade_package() {
    local package="$1"
    
    log_info "Upgrading package: ${package}"
    
    if [[ "${DRY_RUN}" == "true" ]]; then
        log_info "[DRY-RUN] Would upgrade: ${package}"
        return 0
    fi
    
    case "${PKG_MANAGER}" in
        apt)
            apt-get update -qq
            DEBIAN_FRONTEND=noninteractive apt-get install --only-upgrade -y "${package}" >> "${LOG_FILE}" 2>&1
            ;;
        yum)
            yum update -y "${package}" >> "${LOG_FILE}" 2>&1
            ;;
        apk)
            apk upgrade "${package}" >> "${LOG_FILE}" 2>&1
            ;;
    esac
    
    local exit_code=$?
    if [[ $exit_code -eq 0 ]]; then
        log_success "Successfully upgraded: ${package}"
        return 0
    else
        log_error "Failed to upgrade: ${package} (exit code: ${exit_code})"
        return 1
    fi
}

# Check service health
check_service_health() {
    local service="$1"
    
    if [[ -z "$service" ]]; then
        return 0
    fi
    
    if systemctl is-active --quiet "${service}"; then
        log_info "Service OK: ${service}"
        return 0
    else
        log_error "Service FAILED: ${service}"
        return 1
    fi
}

# Rollback snapshot
rollback_snapshot() {
    if [[ -z "${SNAPSHOT_ID}" ]]; then
        log_error "No snapshot available for rollback"
        return 1
    fi
    
    log_warn "Performing rollback to snapshot: ${SNAPSHOT_ID}"
    
    local snapshot_file="${SNAPSHOT_DIR}/${SNAPSHOT_ID}.tar.gz"
    
    if [[ ! -f "${snapshot_file}" ]]; then
        log_error "Snapshot file not found: ${snapshot_file}"
        return 1
    fi
    
    tar xzf "${snapshot_file}" -C / 2>/dev/null || true
    
    log_success "Rollback complete"
}

# Main remediation logic
main() {
    local input_file=""
    local severities="LOW,MEDIUM"
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --input)
                input_file="$2"
                shift 2
                ;;
            --severity)
                severities="$2"
                shift 2
                ;;
            --allowlist)
                ALLOWLIST_FILE="$2"
                shift 2
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --force)
                FORCE=true
                shift
                ;;
            --skip-snapshot)
                SKIP_SNAPSHOT=true
                shift
                ;;
            --help)
                show_help
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                show_help
                exit 1
                ;;
        esac
    done
    
    if [[ -z "${input_file}" ]]; then
        log_error "Missing required argument: --input"
        show_help
        exit 1
    fi
    
    log_info "Starting automated remediation (severity: ${severities})"
    
    # Prerequisites
    check_prerequisites
    check_maintenance_window
    perform_safety_checks
    load_allowlist
    
    # Parse vulnerabilities
    parse_vulnerabilities "${input_file}" "${severities}"
    
    if [[ ${#VULN_PACKAGES[@]} -eq 0 ]]; then
        log_info "No vulnerabilities found for remediation"
        exit 0
    fi
    
    # Create snapshot
    create_snapshot
    
    # Process each package
    for package in "${VULN_PACKAGES[@]}"; do
        # Check if allowed
        if ! is_allowed "$package"; then
            log_warn "Skipping ${package} (not in allowlist)"
            continue
        fi
        
        # Get associated services
        local services=$(get_package_services "$package")
        
        # Upgrade package
        if upgrade_package "$package"; then
            ((PATCHES_APPLIED++))
            
            # Check service health
            if [[ -n "$services" ]]; then
                for service in $services; do
                    if ! check_service_health "$service"; then
                        log_error "Service health check failed after upgrade: ${service}"
                        rollback_snapshot
                        ((FAILURES++))
                        break
                    fi
                done
            fi
        else
            ((FAILURES++))
        fi
    done
    
    # Summary
    echo ""
    echo "========================================"
    echo "  Automated Remediation Summary"
    echo "========================================"
    echo "Packages processed: ${#VULN_PACKAGES[@]}"
    echo "Patches applied: ${PATCHES_APPLIED}"
    echo "Failures: ${FAILURES}"
    echo "Snapshot: ${SNAPSHOT_ID:-none}"
    echo "========================================"
    
    if [[ "${DRY_RUN}" == "true" ]]; then
        log_info "Dry-run complete (no changes made)"
    fi
    
    if [[ ${FAILURES} -gt 0 ]]; then
        exit 1
    fi
    
    exit 0
}

main "$@"
